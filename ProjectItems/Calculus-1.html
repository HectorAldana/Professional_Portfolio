<!DOCTYPE html>
<html lang="en">
   <head>
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Github Professional Portfolio</title>
      <link rel="stylesheet" href="../index.css">
   </head>
   <body>
      <header>
         <h1>Hector Guido Aldana</h1>
         <h2>MSc in Software Engineering | MSc in Data Science</h2>
      </header>
      <section id="project">
         <h3>Multivariable Calculus & Complex Analysis</h3>
         <article id="linear-transformation">
            <h3>Introduction</h3>
            <h4>Objective:</h4>
            <p>To demonstrate and analyze the process of image rotation as a linear transformation in R2 space, focusing on grayscale imagery.</p>
            <h4>Background:</h4>
            <p>This project investigates the mathematical concept of linear transformations, particularly rotation in a two-dimensional plane, and its practical application in image processing.</p>
            <h3>Concept and Implementation</h3>
            <h4>Theory:</h4>
            <p>The project is centered around the rotation matrix, a linear transformation used for rotating vectors in a plane. Defined using sine (\(\sin\)) and cosine (\(\cos\)) functions, the matrix is pivotal for determining new coordinates after rotation, where \(\theta\) is the rotation angle. The simplicity of linear transformations is explored using grayscale images, which are 2D arrays of pixel intensities, in contrast to the more complex approach required for color images with multiple layers.</p>
            <h4>Tools:</h4>
            <p>The project utilizes Python for its powerful library support. OpenCV (cv2) is employed for image processing tasks, though the project specifically focuses on manually applying the rotation matrix to demonstrate the application of linear algebra in image manipulation. This approach offers a deeper understanding of the fundamental processes behind image rotation.</p>
            <h4>Process:</h4>
            <p>The implementation involves manually creating a rotation matrix based on a given angle, applying this matrix to each pixel of a grayscale image, and contrasting this approach with OpenCV's built-in rotation functions.</p>
            <h4>Example:</h4>
            <p>To illustrate the concept, consider rotating a pixel located at coordinates \((x, y)\) about the origin by an angle \(\theta\). The rotation matrix is shown below:</p>
            <img src="../Images/rotation_matrix.png" alt="Rotation Matrix" style="display: block; margin-left: auto; margin-right: auto;">
            <p>For a pixel at \((3, 4)\) rotated by \(45^\circ\), the new coordinates \((x', y')\) are calculated as follows:</p>
            <img src="../Images/rotation_calculation.png" alt="Rotation Calculation" style="display: block; margin-left: auto; margin-right: auto;">
            <p>Thus, the new coordinates of the pixel after rotation by \(45^\circ\) are approximately \((-1/\sqrt{2}, 7/\sqrt{2})\). This example demonstrates the practical application of the rotation matrix to a single pixel, which can be extended to every pixel in an image for a complete rotation transformation.</p>
            <h3>Python Code Implementation:</h3>

<pre class="code-block"><code>
<span class="keyword">import</span> cv2
<span class="keyword">import</span> numpy <span class="keyword">as</span> np
<span class="keyword">import</span> math

<span class="keyword">def</span> rotate_image_manual(image_path, angle):
    <span class="comment"># Load the image</span>
    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)  <span class="comment"># Load as grayscale for simplicity</span>
    height, width = image.shape

    <span class="comment"># Create a new image with the same size but filled with zeros (black)</span>
    rotated_image = np.zeros((height, width), dtype=np.uint8)

    <span class="comment"># Calculate the center of the image</span>
    center_y, center_x = height <span class="keyword">//</span> 2, width <span class="keyword">//</span> 2

    <span class="comment"># Convert the angle to radians</span>
    angle_rad = math.radians(angle)

    <span class="comment"># Create the rotation matrix</span>
    rotation_matrix = np.array([
        [math.cos(angle_rad), -math.sin(angle_rad)],
        [math.sin(angle_rad), math.cos(angle_rad)]
    ])

    <span class="comment"># Apply the transformation to each pixel</span>
    <span class="keyword">for</span> y <span class="keyword">in</span> range(height):
        <span class="keyword">for</span> x <span class="keyword">in</span> range(width):
            <span class="comment"># Translate the pixel to origin and then rotate</span>
            yp = y - center_y
            xp = x - center_x
            new_x, new_y = np.matmul(rotation_matrix, np.array([xp, yp]))

            <span class="comment"># Translate back from the origin</span>
            new_x += center_x
            new_y += center_y

            <span class="comment"># If the new position is within the bounds of the image, set the pixel</span>
            <span class="keyword">if</span> 0 <= new_x < width <span class="keyword">and</span> 0 <= new_y < height:
                rotated_image[int(new_y), int(new_x)] = image[y, x]

    <span class="comment"># Display the original and rotated images</span>
    cv2.imshow('Original Image', image)
    cv2.imshow('Rotated Image', rotated_image)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

<span class="comment"># Use the function</span>
rotate_image_manual('path_to_your_image.jpg', -45)  <span class="comment"># Replace with your image path and desired rotation angle</span>
</code></pre>

<div class="image-container">
        <img src="../ProjectSourceCode/Calculus-1/Sheep.jpg" alt="Sheep" class="image">
        <img src="../ProjectSourceCode/Calculus-1/Sheep-grayscale.png" alt="Sheep in Grayscale" class="image">
        <img src="../ProjectSourceCode/Calculus-1/Sheep-grayscale-counterclockwise-45degrees.png" alt="Sheep Rotated 45 Degrees Counterclockwise" class="image">
</div>
<p><a href="../ProjectSourceCode/Calculus-1/Linear_Transformation_2D_Rotation.py" download="Linear_Transformation_2D_Rotation.py">Download Python Source Code...</a></p>
<p><a href="../ProjectSourceCode/Calculus-1/Sheep.jpg" download="Sheep.jpg">Download test image...</a></p>

<h3>Troubleshooting </h3>
<h4>Version issue:</h4>
<p>TypeError: 'numpy._DTypeMeta' object is not subscriptable</p>
<p>Solution: In Anaconda.Navigator Terminal for Jupyter.Notebook, run the following command: </p>
<pre class="code-block"><code>            
pip install numpy --upgrade
</code></pre>

<h4>File path issue:</h4>
<p>Solution: In Jupyter.Notebook, run the following command: </p>
<pre class="code-block"><code>            
import os

<span class="comment"># Define the desired directory path</span>
new_directory = r"C:\path_to_your_image"

<span class="comment"># Change the current working directory</span>
os.chdir(new_directory)

<span class="comment"># Verify the change</span>
print("Current Working Directory: ", os.getcwd())

</code></pre>


            <h3>Results and Discussion</h3>
            <h4>Findings:</h4>
            <p>The manual application of the rotation matrix effectively rotates the images, confirming the matrix's capability in transforming pixel positions.</p>
            <h4>Analysis:</h4>
            <p>These results underscore the importance of linear algebra in image processing. The project highlights the balance between theory and practice, demonstrating how abstract mathematical concepts can be directly applied to practical tasks like image rotation. The comparison with OpenCV's methods also sheds light on the complexities of handling color images versus grayscale images in the context of linear transformations.</p>
            <h3>Real-World Application</h3>
            <h4>Practical Use:</h4>
            <p>This concept finds extensive use in image processing and computer graphics, particularly in applications that require precise control over image manipulation, such as photo editing and animation.</p>
            <h3>Conclusion</h3>
            <h4>Summary:</h4>
            <p>This project effectively bridges the gap between theoretical mathematics and practical computer vision applications, illustrating the significance of linear transformation theory in real-world scenarios. By manually implementing the rotation matrix on grayscale images, it emphasizes the foundational role of mathematics in image processing and highlights the comparative simplicity of grayscale transformations over color image processing.</p>
            <h3>References</h3>
            <p>Literature and Resources: Lay, D. C. (2021). Linear Algebra and Its Applications (6th ed., p. 76, Section 1.9 The Matrix of a Linear Transformation). Pearson. ISBN-13: 978-0-13-585104-3.</p>
         </article>
      </section>
   </body>
</html>