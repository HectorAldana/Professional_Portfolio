<!DOCTYPE html>
<html lang="en">
   <head>
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Github Professional Portfolio</title>
      <link rel="stylesheet" href="../index.css">
   </head>
   <body>
      <header>
         <h1>Hector Guido Aldana</h1>
         <h2>MSc in Software Engineering | MSc in Data Science</h2>
      </header>
      <section id="project">
         <h3>Multivariable Calculus & Complex Analysis</h3>
         <article id="linear-transformation">
            <h3>Introduction</h3>
            <h4>Objective:</h4>
            <p>To demonstrate and analyze the process of image rotation as a linear transformation in R2 space, focusing on grayscale imagery.</p>
            <h4>Background:</h4>
            <p>This project investigates the mathematical concept of linear transformations, particularly rotation in a two-dimensional plane, and its practical application in image processing.</p>
            <h3>Concept and Implementation</h3>
            <h4>Theory:</h4>
            <p>The project is centered around the rotation matrix, a linear transformation used for rotating vectors in a plane. Defined using sine (\(\sin\)) and cosine (\(\cos\)) functions, the matrix is pivotal for determining new coordinates after rotation, where \(\theta\) is the rotation angle. The simplicity of linear transformations is explored using grayscale images, which are 2D arrays of pixel intensities, in contrast to the more complex approach required for color images with multiple layers.</p>
            <p><strong>Rotation Matrix Derivation:</strong></p>
            <p>In the case of a circle of radius \( r \), any point on the circle can be described using the equations:</p>
            <p>\[ x = r \cos(\alpha) \]</p>
            <p>\[ y = r \sin(\alpha) \]</p>
            <p>where \( \alpha \) is the angle from the positive x-axis to the point. After rotating this point by an angle \( \theta \), the new coordinates (\( x' \), \( y' \)) can be expressed using the rotation matrix:</p>
            <p>\[ x' = x \cos(\theta) - y \sin(\theta) \]</p>
            <p>\[ y' = x \sin(\theta) + y \cos(\theta) \]</p>
            <p><strong>Matrix Formulation:</strong></p>
            <p>The rotation matrix in 2D space for a rotation by an angle \( \theta \) is given by:</p>
            <p>\[ 
               \begin{bmatrix}
               \cos(\theta) & -\sin(\theta) \\
               \sin(\theta) & \cos(\theta)
               \end{bmatrix}
               \]
            </p>
            <p><strong>Cosine and Sine in the Matrix:</strong></p>
            <p>The cosine and sine functions in the rotation matrix correspond to the rotated coordinates on the unit circle. They determine the new x and y coordinates of a point after a rotation transformation:</p>
            <p>\[ 
               \begin{bmatrix}
               \cos(\theta) & -\sin(\theta) \\
               \sin(\theta) & \cos(\theta)
               \end{bmatrix}
               \begin{bmatrix}
               x \\
               y
               \end{bmatrix}
               =
               \begin{bmatrix}
               x' \\
               y'
               \end{bmatrix}
               \]
            </p>
            <p>This matrix will rotate a point (\( x, y \)) around the origin by the angle \( \theta \).</p>
            <h4>Tools:</h4>
            <p>The project utilizes Python for its powerful library support. OpenCV (cv2) is employed for image processing tasks, though the project specifically focuses on manually applying the rotation matrix to demonstrate the application of linear algebra in image manipulation. This approach offers a deeper understanding of the fundamental processes behind image rotation.</p>
            <h4>Process:</h4>
            <p>The implementation involves manually creating a rotation matrix based on a given angle, applying this matrix to each pixel of a grayscale image, and contrasting this approach with OpenCV's built-in rotation functions.</p>
            <h4>Example:</h4>
            <p>To illustrate the concept, consider rotating a pixel located at coordinates \((x, y)\) about the origin by an angle \(\theta\). The rotation matrix is shown below:</p>
            <img src="../Images/rotation_matrix.png" alt="Rotation Matrix" style="display: block; margin-left: auto; margin-right: auto;">
            <p>For a pixel at \((3, 4)\) rotated by \(45^\circ\), the new coordinates \((x', y')\) are calculated as follows:</p>
            <img src="../Images/rotation_calculation.png" alt="Rotation Calculation" style="display: block; margin-left: auto; margin-right: auto;">
            <p>Thus, the new coordinates of the pixel after rotation by \(45^\circ\) are approximately \((-1/\sqrt{2}, 7/\sqrt{2})\). This example demonstrates the practical application of the rotation matrix to a single pixel, which can be extended to every pixel in an image for a complete rotation transformation.</p>
            <h4>Intersecting Example and Theory:</h4>
            <p>Rotation is a linear transformation of space from \( \mathbb{R}^2 \) to \( \mathbb{R}^2 \). In mathematical terms, a rotation operation takes a two-dimensional vector as input and outputs another two-dimensional vector, adhering to the principles of linear transformations. We convert \((x, y)\)  to \((x', y')\).</p>
            <ul>
               <li><strong>Rotation in \( \mathbb{R}^2 \):</strong> When we rotate a vector in a two-dimensional space (e.g., the plane of a computer screen or a piece of paper), we are essentially moving it around a fixed point (usually the origin) without changing its length. We can describe the rotation by an angle \( \theta \), and the transformation changes the vector's direction while keeping its magnitude constant.</li>
               <li>
                  <strong>Linear Transformation Properties:</strong>
                  <ul>
                     <li><em>Additivity:</em> For any two vectors \( \mathbf{v} \) and \( \mathbf{w} \) in \( \mathbb{R}^2 \), the rotation of their sum is equal to the sum of their rotations. Mathematically, if \( R \) is a rotation operation, then \( R(\mathbf{v} + \mathbf{w}) = R(\mathbf{v}) + R(\mathbf{w}) \).</li>
                     <li><em>Homogeneity:</em> For any vector \( \mathbf{v} \) in \( \mathbb{R}^2 \) and any scalar \( a \), the rotation of the scaled vector is the same as scaling the rotated vector. In other words, \( R(a\mathbf{v}) = aR(\mathbf{v}) \).</li>
                  </ul>
               </li>
               <li>
                  <strong>Matrix Representation:</strong>
                  <p>Rotation in \( \mathbb{R}^2 \) can be represented by a 2x2 matrix (as discussed in the previous explanation about cosine and sine in the rotation matrix). This matrix operates on 2D vectors; the resulting vectors are also in 2D space.</p>
               </li>
               <li><strong>Preservation of Structure:</strong> Importantly, rotation preserves the linear structure of the space. Distances and angles between vectors (except for the rotation angle) are maintained, a characteristic of linear transformations.</li>
            </ul>
            <p>Thus, rotation is indeed a linear transformation in \( \mathbb{R}^2 \) space, as it maps vectors from \( \mathbb{R}^2 \) to \( \mathbb{R}^2 \) while preserving linearity.</p>
            <h3>Python Code Implementation:</h3>
            <pre class="code-block"><code>
<span class="keyword">import</span> cv2
<span class="keyword">import</span> numpy <span class="keyword">as</span> np
<span class="keyword">import</span> math

<span class="keyword">def</span> rotate_image_manual(image_path, angle):
    <span class="comment"># Load the image</span>
    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)  <span class="comment"># Load as grayscale for simplicity</span>
    height, width = image.shape

    <span class="comment"># Create a new image with the same size but filled with zeros (black)</span>
    rotated_image = np.zeros((height, width), dtype=np.uint8)

    <span class="comment"># Calculate the center of the image</span>
    center_y, center_x = height <span class="keyword">//</span> 2, width <span class="keyword">//</span> 2

    <span class="comment"># Convert the angle to radians</span>
    angle_rad = math.radians(angle)

    <span class="comment"># Create the rotation matrix</span>
    rotation_matrix = np.array([
        [math.cos(angle_rad), -math.sin(angle_rad)],
        [math.sin(angle_rad), math.cos(angle_rad)]
    ])

    <span class="comment"># Apply the transformation to each pixel</span>
    <span class="keyword">for</span> y <span class="keyword">in</span> range(height):
        <span class="keyword">for</span> x <span class="keyword">in</span> range(width):
            <span class="comment"># Translate the pixel to origin and then rotate</span>
            yp = y - center_y
            xp = x - center_x
            new_x, new_y = np.matmul(rotation_matrix, np.array([xp, yp]))

            <span class="comment"># Translate back from the origin</span>
            new_x += center_x
            new_y += center_y

            <span class="comment"># If the new position is within the bounds of the image, set the pixel</span>
            <span class="keyword">if</span> 0 <= new_x < width <span class="keyword">and</span> 0 <= new_y < height:
                rotated_image[int(new_y), int(new_x)] = image[y, x]

    <span class="comment"># Display the original and rotated images</span>
    cv2.imshow('Original Image', image)
    cv2.imshow('Rotated Image', rotated_image)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

<span class="comment"># Use the function</span>
rotate_image_manual('path_to_your_image.jpg', -45)  <span class="comment"># Replace with your image path and desired rotation angle</span>
</code></pre>
            <div class="image-container">
               <img src="../ProjectSourceCode/Calculus-1/Sheep.jpg" alt="Sheep" class="image">
               <img src="../ProjectSourceCode/Calculus-1/Sheep-grayscale.png" alt="Sheep in Grayscale" class="image">
               <img src="../ProjectSourceCode/Calculus-1/Sheep-clipped.png" alt="Sheep clipped" class="image">
               <img src="../ProjectSourceCode/Calculus-1/Sheep-grayscale-counterclockwise-90degrees.png" alt="Sheep Rotated 45 Degrees Counterclockwise" class="image">
            </div>
            <p><a href="../ProjectSourceCode/Calculus-1/Linear_Transformation_2D_Rotation.py" download="Linear_Transformation_2D_Rotation.py">Download Python Source Code...</a></p>
            <p><a href="../ProjectSourceCode/Calculus-1/Sheep.jpg" download="Sheep.jpg">Download test image...</a></p>
            <h3>Troubleshooting </h3>
            <h4>Version issue:</h4>
            <p>TypeError: 'numpy._DTypeMeta' object is not subscriptable</p>
            <p>Solution: In Anaconda.Navigator Terminal for Jupyter.Notebook, run the following command: </p>
            <pre class="code-block"><code>            
pip install numpy --upgrade
</code></pre>
            <h4>File path issue:</h4>
            <p>Solution: In Jupyter.Notebook, run the following command: </p>
            <pre class="code-block"><code>            
import os

<span class="comment"># Define the desired directory path</span>
new_directory = "C:\path_to_your_image"

<span class="comment"># Change the current working directory</span>
os.chdir(new_directory)

<span class="comment"># Verify the change</span>
print("Current Working Directory: ", os.getcwd())

</code></pre>
            <h3>Results and Discussion</h3>
            <h4>Findings:</h4>
            <h5>Image quality and angle of rotation:</h5>
            <p>The manual application of the rotation matrix effectively rotates the images, confirming the matrix's capability in transforming pixel positions. Nonetheless, rotating an image involves mapping pixels from the original image to new positions in the rotated image. If the rotation angle is not a multiple of 90 degrees, most pixels in the rotated image will not align exactly with pixels in the original image. Try 45 degrees counterclockwise first. Then try 90 degrees and notice the loss in image quality.</p>
            <h5>Clipped image:</h5>
            <p>The code can be enhanced by calculating the new image size</p>
            <pre class="code-block"><code>            
    <span class="comment"># Calculate new image width and height</span>
    new_width = int(abs(width * math.cos(angle_rad)) + abs(height * math.sin(angle_rad)))
    new_height = int(abs(height * math.cos(angle_rad)) + abs(width * math.sin(angle_rad)))

    <span class="comment"># Create a new image with the calculated size</span>
    rotated_image = np.zeros((new_height, new_width), dtype=np.uint8)

    <span class="comment"># Calculate the center of the new image</span>
    center_y, center_x = new_height // 2, new_width // 2

</code></pre>
            <div class="image-container">
               <img src="../ProjectSourceCode/Calculus-1/Sheep.jpg" alt="Sheep" class="image">
               <img src="../ProjectSourceCode/Calculus-1/Sheep-grayscale.png" alt="Sheep in Grayscale" class="image">
               <img src="../ProjectSourceCode/Calculus-1/Sheep-grayscale-counterclockwise-45degrees.png" alt="Sheep Rotated 45 Degrees Counterclockwise" class="image">
               <img src="../ProjectSourceCode/Calculus-1/Sheep-grayscale-counterclockwise-90degrees.png" alt="Sheep Rotated 45 Degrees Counterclockwise" class="image">
            </div>
            <h4>Analysis:</h4>
            <p>These results underscore the importance of linear algebra in image processing. The project highlights the balance between theory and practice, demonstrating how abstract mathematical concepts can be directly applied to practical tasks like image rotation. The comparison with OpenCV's methods also sheds light on the complexities of handling color images versus grayscale images in the context of linear transformations.</p>
            <h3>Real-World Application</h3>
            <h4>Practical Use:</h4>
            <p>This concept finds extensive use in image processing and computer graphics, particularly in applications that require precise control over image manipulation, such as photo editing and animation.</p>
            <h3>Conclusion</h3>
            <h4>Summary:</h4>
            <p>This project effectively bridges the gap between theoretical mathematics and practical computer vision applications, illustrating the significance of linear transformation theory in real-world scenarios. By manually implementing the rotation matrix on grayscale images, it emphasizes the foundational role of mathematics in image processing and highlights the comparative simplicity of grayscale transformations over color image processing.</p>
            <h4>Next steps:</h4>
            <p>We can use libraries like NumPy for matrix operations and OpenCV to achieve the linear transformation without deep diving into the mathematics. Below is a code example. What makes their libraries tick? </p>
            <pre class="code-block"><code>
<span class="keyword">import</span> cv2
<span class="keyword">import</span> numpy <span class="keyword">as</span> np

def rotate_image(image_path, angle):
    <span class="comment"># Load the image</span>
    image = cv2.imread(image_path)

    <span class="comment"># Get the image dimensions</span>
    height, width = image.shape[:2]

    <span class="comment"># Calculate the center of the image</span>
    center = (width / 2, height / 2)

    <span class="comment"># Calculate the rotation matrix</span>
    <span class="comment"># cv2.getRotationMatrix2D needs center, angle, scale</span>
    rotation_matrix = cv2.getRotationMatrix2D(center, angle, 1)

    <span class="comment"># Perform the rotation</span>
    rotated_image = cv2.warpAffine(image, rotation_matrix, (width, height))

    <span class="comment"># Display the original and rotated images</span>
    cv2.imshow('Original Image', image)
    cv2.imshow('Rotated Image', rotated_image)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

<span class="comment"># Use the function</span>
rotate_image('path_to_your_image.jpg', 45)  # Replace 'path_to_your_image.jpg' with your image file path

</code></pre>
            <div class="image-container">
               <img src="../ProjectSourceCode/Calculus-1/OpenCV-45.png" alt="OpenCV&Numpy -45 degress" class="image">
               <img src="../ProjectSourceCode/Calculus-1/OpenCV-90.png" alt="OpenCV&Numpy -90 degress" class="image">
            </div>
            <p>We completed a manual rotation and showed the OpenCV-based rotation code. The manual rotation outcome showed less quality than the OpenCV-based rotation, primarily because of pixel interpolation issues.</p>
            <p>Our manual rotation code assigns pixel values directly without interpolating. This approach leads to aliasing and jagged edges. On the other hand, OpenCV's warpAffine uses sophisticated interpolation methods (e.g., bilinear or bicubic interpolation) to calculate pixel values, resulting in smoother and more visually appealing images.</p>
            <p>The manual method assigns new pixel values based on the original image's coordinates transformed by the rotation matrix. That leads to issues like holes (pixels in the new image that are not assigned a value) or overlaps (multiple original pixels mapping to the same new pixel). </p>
            <p>We saw that the way we calculate the new image size to accommodate the rotated image determines whether the image is clipped or shows unnecessary padding. OpenCV does a graceful job here, with highly optimized functions for performance and considering speed and memory usage. They are written in optimized C/C++ and often use hardware acceleration, making them more efficient than manually written code in Python. </p>
            <p>C/C++ is a lower-level programming language and offers more control over system resources like memory and processing power. Moreover, OpenCV's C/C++ functions may take advantage of optimization techniques like loop unrolling, efficient use of data structures, and minimal use of redundant computations. Achieving similar results with Python alone poses a good challenge.</p>
            <h3>References</h3>
            <p>Lay, D. C. (2021). Linear Algebra and Its Applications (6th ed., p. 76, Section 1.9 The Matrix of a Linear Transformation). Pearson. ISBN-13: 978-0-13-585104-3.</p>
            <p>Kreyszig, E. (2011). Advanced engineering mathematics (10th ed., pp. 271-272). John Wiley & Sons.</p>
         </article>
      </section>
   </body>
</html>